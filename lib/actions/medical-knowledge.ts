'use server'

import { createServiceClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'

/**
 * Upload medical knowledge entry with text content
 * The embeddings will be generated by Supabase Edge Function or LangFlow
 */
export async function uploadMedicalKnowledgeAction(formData: {
  title: string
  content: string
  sourceType: 'textbook' | 'research_paper' | 'clinical_protocol' | 'case_study' | 'guideline'
  specialty: 'endodontics' | 'periodontics' | 'prosthodontics' | 'oral_surgery' | 'general_dentistry'
  authors?: string
  publicationYear?: number
  journal?: string
  doi?: string
  url?: string
  isbn?: string
  topics: string[]
  diagnosisKeywords: string[]
  treatmentKeywords: string[]
}) {
  try {
    const supabase = await createServiceClient()

    // Verify user is authenticated dentist
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return { success: false, error: 'Unauthorized' }
    }

    const { data: profile } = await supabase
      .from('profiles')
      .select('role, status')
      .eq('id', user.id)
      .single()

    if (!profile || profile.role !== 'dentist' || profile.status !== 'active') {
      return { success: false, error: 'Only active dentists can upload medical knowledge' }
    }

    console.log('üìö [MEDICAL KNOWLEDGE] Uploading new knowledge entry:', {
      title: formData.title,
      sourceType: formData.sourceType,
      contentLength: formData.content.length,
      topics: formData.topics,
      uploadedBy: user.id
    })

    // Generate embedding using Google Gemini
    const GEMINI_API_KEY = process.env.GEMINI_API_KEY
    if (!GEMINI_API_KEY) {
      return { success: false, error: 'GEMINI_API_KEY not configured. Please add it to .env.local' }
    }

    // Create embedding text (combine title and content)
    const embeddingText = `${formData.title}\n\n${formData.content}`

    console.log('üîÆ [MEDICAL KNOWLEDGE] Generating 768-dim embedding with Gemini...')

    // Import Gemini service
    const { generateEmbedding } = await import('@/lib/services/gemini-ai')

    let embedding: number[]
    try {
      embedding = await generateEmbedding(embeddingText, 'RETRIEVAL_DOCUMENT')
      console.log('‚úÖ [MEDICAL KNOWLEDGE] Gemini embedding generated, dimensions:', embedding.length)
    } catch (error) {
      console.error('‚ùå [MEDICAL KNOWLEDGE] Gemini embedding failed:', error)
      return { success: false, error: 'Failed to generate embeddings with Gemini API' }
    }

    // Insert into database with embedding
    const { data: knowledgeEntry, error: insertError } = await supabase
      .from('medical_knowledge')
      .insert({
        title: formData.title,
        content: formData.content,
        source_type: formData.sourceType,
        specialty: formData.specialty,
        authors: formData.authors || null,
        publication_year: formData.publicationYear || null,
        journal: formData.journal || null,
        doi: formData.doi || null,
        url: formData.url || null,
        isbn: formData.isbn || null,
        embedding: embedding,
        topics: formData.topics,
        diagnosis_keywords: formData.diagnosisKeywords,
        treatment_keywords: formData.treatmentKeywords,
        uploaded_by: user.id
      })
      .select()
      .single()

    if (insertError) {
      console.error('‚ùå [MEDICAL KNOWLEDGE] Database insert failed:', insertError)
      return { success: false, error: insertError.message }
    }

    console.log('‚úÖ [MEDICAL KNOWLEDGE] Successfully uploaded:', knowledgeEntry.id)

    revalidatePath('/dentist')
    revalidatePath('/dentist/knowledge')

    return { success: true, data: knowledgeEntry }

  } catch (error) {
    console.error('‚ùå [MEDICAL KNOWLEDGE] Upload error:', error)
    return { success: false, error: 'Failed to upload medical knowledge' }
  }
}

/**
 * Get all medical knowledge entries
 */
export async function getMedicalKnowledgeAction(filters?: {
  sourceType?: string
  specialty?: string
  searchQuery?: string
}) {
  try {
    const supabase = await createServiceClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return { success: false, error: 'Unauthorized' }
    }

    let query = supabase
      .from('medical_knowledge')
      .select('*')
      .order('created_at', { ascending: false })

    // Apply filters
    if (filters?.sourceType) {
      query = query.eq('source_type', filters.sourceType)
    }

    if (filters?.specialty) {
      query = query.eq('specialty', filters.specialty)
    }

    if (filters?.searchQuery) {
      query = query.or(`title.ilike.%${filters.searchQuery}%,content.ilike.%${filters.searchQuery}%`)
    }

    const { data, error } = await query

    if (error) {
      console.error('‚ùå [MEDICAL KNOWLEDGE] Fetch error:', error)
      return { success: false, error: error.message }
    }

    return { success: true, data }

  } catch (error) {
    console.error('‚ùå [MEDICAL KNOWLEDGE] Error:', error)
    return { success: false, error: 'Failed to fetch medical knowledge' }
  }
}

/**
 * Delete medical knowledge entry
 */
export async function deleteMedicalKnowledgeAction(knowledgeId: string) {
  try {
    const supabase = await createServiceClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return { success: false, error: 'Unauthorized' }
    }

    // Check if user is the uploader or admin
    const { data: knowledge } = await supabase
      .from('medical_knowledge')
      .select('uploaded_by')
      .eq('id', knowledgeId)
      .single()

    if (!knowledge || knowledge.uploaded_by !== user.id) {
      return { success: false, error: 'You can only delete your own uploads' }
    }

    const { error: deleteError } = await supabase
      .from('medical_knowledge')
      .delete()
      .eq('id', knowledgeId)

    if (deleteError) {
      return { success: false, error: deleteError.message }
    }

    console.log('‚úÖ [MEDICAL KNOWLEDGE] Deleted entry:', knowledgeId)

    revalidatePath('/dentist')
    revalidatePath('/dentist/knowledge')

    return { success: true }

  } catch (error) {
    console.error('‚ùå [MEDICAL KNOWLEDGE] Delete error:', error)
    return { success: false, error: 'Failed to delete medical knowledge' }
  }
}

/**
 * Get knowledge base statistics
 */
export async function getKnowledgeStatsAction() {
  try {
    const supabase = await createServiceClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return { success: false, error: 'Unauthorized' }
    }

    const { data: allKnowledge } = await supabase
      .from('medical_knowledge')
      .select('source_type, specialty, topics')

    if (!allKnowledge) {
      return { success: true, data: { total: 0, byType: {}, bySpecialty: {}, byTopic: {} } }
    }

    const stats = {
      total: allKnowledge.length,
      byType: {} as Record<string, number>,
      bySpecialty: {} as Record<string, number>,
      byTopic: {} as Record<string, number>
    }

    allKnowledge.forEach((entry) => {
      // Count by source type
      stats.byType[entry.source_type] = (stats.byType[entry.source_type] || 0) + 1

      // Count by specialty
      stats.bySpecialty[entry.specialty] = (stats.bySpecialty[entry.specialty] || 0) + 1

      // Count by topics
      if (entry.topics) {
        entry.topics.forEach((topic: string) => {
          stats.byTopic[topic] = (stats.byTopic[topic] || 0) + 1
        })
      }
    })

    return { success: true, data: stats }

  } catch (error) {
    console.error('‚ùå [MEDICAL KNOWLEDGE] Stats error:', error)
    return { success: false, error: 'Failed to fetch statistics' }
  }
}
