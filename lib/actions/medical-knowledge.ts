'use server'

import { createServiceClient, createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { getCurrentUser } from './auth'

/**
 * Upload medical knowledge entry with text content
 * The embeddings will be generated by Supabase Edge Function or LangFlow
 */
export async function uploadMedicalKnowledgeAction(formData: {
  title: string
  content: string
  sourceType: 'textbook' | 'research_paper' | 'clinical_protocol' | 'case_study' | 'guideline'
  specialty: 'endodontics' | 'periodontics' | 'prosthodontics' | 'oral_surgery' | 'general_dentistry'
  authors?: string
  publicationYear?: number
  journal?: string
  doi?: string
  url?: string
  isbn?: string
  topics: string[]
  diagnosisKeywords: string[]
  treatmentKeywords: string[]
}) {
  try {
    // Get current user using proper auth pattern
    const user = await getCurrentUser()
    if (!user || user.role !== 'dentist' || user.status !== 'active') {
      return { success: false, error: 'Only active dentists can upload medical knowledge' }
    }

    // Use service client for database operations
    const supabase = await createServiceClient()

    console.log('üìö [MEDICAL KNOWLEDGE] Uploading new knowledge entry:', {
      title: formData.title,
      sourceType: formData.sourceType,
      contentLength: formData.content.length,
      topics: formData.topics,
      uploadedBy: user.id
    })

    // Generate embedding using Google Gemini
    const GEMINI_API_KEY = process.env.GEMINI_API_KEY
    if (!GEMINI_API_KEY) {
      return { success: false, error: 'GEMINI_API_KEY not configured. Please add it to .env.local' }
    }

    // Create embedding text (combine title and content)
    const embeddingText = `${formData.title}\n\n${formData.content}`

    console.log('üîÆ [MEDICAL KNOWLEDGE] Generating 768-dim embedding with Gemini...')

    // Import Gemini service
    const { generateEmbedding } = await import('@/lib/services/gemini-ai')

    let embedding: number[]
    try {
      embedding = await generateEmbedding(embeddingText, 'RETRIEVAL_DOCUMENT')
      console.log('‚úÖ [MEDICAL KNOWLEDGE] Gemini embedding generated, dimensions:', embedding.length)
    } catch (error) {
      console.error('‚ùå [MEDICAL KNOWLEDGE] Gemini embedding failed:', error)
      return { success: false, error: 'Failed to generate embeddings with Gemini API' }
    }

    // Insert into database with embedding
    const { data: knowledgeEntry, error: insertError} = await supabase
      .schema('api')
      .from('medical_knowledge')
      .insert({
        title: formData.title,
        content: formData.content,
        source_type: formData.sourceType,
        specialty: formData.specialty,
        authors: formData.authors || null,
        publication_year: formData.publicationYear || null,
        journal: formData.journal || null,
        doi: formData.doi || null,
        url: formData.url || null,
        isbn: formData.isbn || null,
        embedding: embedding,
        topics: formData.topics,
        diagnosis_keywords: formData.diagnosisKeywords,
        treatment_keywords: formData.treatmentKeywords,
        uploaded_by: user.id
      })
      .select()
      .single()

    if (insertError) {
      console.error('‚ùå [MEDICAL KNOWLEDGE] Database insert failed:', insertError)
      return { success: false, error: insertError.message }
    }

    console.log('‚úÖ [MEDICAL KNOWLEDGE] Successfully uploaded:', knowledgeEntry.id)

    revalidatePath('/dentist')
    revalidatePath('/dentist/knowledge')

    return { success: true, data: knowledgeEntry }

  } catch (error) {
    console.error('‚ùå [MEDICAL KNOWLEDGE] Upload error:', error)
    return { success: false, error: 'Failed to upload medical knowledge' }
  }
}

/**
 * Get all medical knowledge entries
 */
export async function getMedicalKnowledgeAction(filters?: {
  sourceType?: string
  specialty?: string
  searchQuery?: string
}) {
  try {
    const supabase = await createServiceClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return { success: false, error: 'Unauthorized' }
    }

    let query = supabase
      .schema('api')
      .from('medical_knowledge')
      .select('*')
      .order('created_at', { ascending: false })

    // Apply filters
    if (filters?.sourceType) {
      query = query.eq('source_type', filters.sourceType)
    }

    if (filters?.specialty) {
      query = query.eq('specialty', filters.specialty)
    }

    if (filters?.searchQuery) {
      query = query.or(`title.ilike.%${filters.searchQuery}%,content.ilike.%${filters.searchQuery}%`)
    }

    const { data, error } = await query

    if (error) {
      console.error('‚ùå [MEDICAL KNOWLEDGE] Fetch error:', error)
      return { success: false, error: error.message }
    }

    return { success: true, data }

  } catch (error) {
    console.error('‚ùå [MEDICAL KNOWLEDGE] Error:', error)
    return { success: false, error: 'Failed to fetch medical knowledge' }
  }
}

/**
 * Delete medical knowledge entry
 */
export async function deleteMedicalKnowledgeAction(knowledgeId: string) {
  try {
    const supabase = await createServiceClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return { success: false, error: 'Unauthorized' }
    }

    // Check if user is the uploader or admin
    const { data: knowledge } = await supabase
      .schema('api')
      .from('medical_knowledge')
      .select('uploaded_by')
      .eq('id', knowledgeId)
      .single()

    if (!knowledge || knowledge.uploaded_by !== user.id) {
      return { success: false, error: 'You can only delete your own uploads' }
    }

    const { error: deleteError } = await supabase
      .schema('api')
      .from('medical_knowledge')
      .delete()
      .eq('id', knowledgeId)

    if (deleteError) {
      return { success: false, error: deleteError.message }
    }

    console.log('‚úÖ [MEDICAL KNOWLEDGE] Deleted entry:', knowledgeId)

    revalidatePath('/dentist')
    revalidatePath('/dentist/knowledge')

    return { success: true }

  } catch (error) {
    console.error('‚ùå [MEDICAL KNOWLEDGE] Delete error:', error)
    return { success: false, error: 'Failed to delete medical knowledge' }
  }
}

/**
 * Get knowledge base statistics
 */
export async function getKnowledgeStatsAction() {
  try {
    const supabase = await createServiceClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return { success: false, error: 'Unauthorized' }
    }

    const { data: allKnowledge } = await supabase
      .schema('api')
      .from('medical_knowledge')
      .select('source_type, specialty, topics')

    if (!allKnowledge) {
      return { success: true, data: { total: 0, byType: {}, bySpecialty: {}, byTopic: {} } }
    }

    const stats = {
      total: allKnowledge.length,
      byType: {} as Record<string, number>,
      bySpecialty: {} as Record<string, number>,
      byTopic: {} as Record<string, number>
    }

    allKnowledge.forEach((entry) => {
      // Count by source type
      stats.byType[entry.source_type] = (stats.byType[entry.source_type] || 0) + 1

      // Count by specialty
      stats.bySpecialty[entry.specialty] = (stats.bySpecialty[entry.specialty] || 0) + 1

      // Count by topics
      if (entry.topics) {
        entry.topics.forEach((topic: string) => {
          stats.byTopic[topic] = (stats.byTopic[topic] || 0) + 1
        })
      }
    })

    return { success: true, data: stats }

  } catch (error) {
    console.error('‚ùå [MEDICAL KNOWLEDGE] Stats error:', error)
    return { success: false, error: 'Failed to fetch statistics' }
  }
}

/**
 * Analyze a PDF and suggest topics, diagnosis, and treatment keywords using Gemini.
 * Returns suggestions without saving anything to the database.
 */
export async function analyzeMedicalKeywordsFromPDFAction(params: {
  pdfFile: File
  specialty?: 'endodontics' | 'periodontics' | 'prosthodontics' | 'oral_surgery' | 'general_dentistry'
}) {
  try {
    // Ensure only authenticated active dentists can analyze
    const user = await getCurrentUser()
    if (!user || user.role !== 'dentist' || user.status !== 'active') {
      return { success: false, error: 'Only active dentists can analyze keywords' }
    }

    // Convert PDF to buffer and extract text
    const arrayBuffer = await params.pdfFile.arrayBuffer()
    const buffer = Buffer.from(arrayBuffer)

    const { extractPDFContent, extractKeywords } = await import('@/lib/utils/pdf-extractor')
    const pdfContent = await extractPDFContent(buffer)

    const textForAnalysis = pdfContent.text.substring(0, 8000)

    // Heuristic baseline (fallback)
    const heuristic = extractKeywords(textForAnalysis)

    // Try Gemini JSON extraction
    let aiTopics: string[] | undefined
    let aiDiagnoses: string[] | undefined
    let aiTreatments: string[] | undefined

    try {
      const { generateChatCompletion } = await import('@/lib/services/gemini-ai')

      const systemInstruction = `You are a dental NLP tagger. Extract concise, domain-relevant tags from the provided text.
Return ONLY valid JSON with these keys and arrays of snake_case strings (lowercase, words separated by underscores):
{
  "topics": ["..."],
  "diagnosis_keywords": ["..."],
  "treatment_keywords": ["..."]
}
- Maximum 8 per list.
- Prefer endodontic terminology.
- Use abbreviations where standard (e.g., rct).
- Do not include explanations or any text outside JSON.`

      const userPrompt = `Analyze the following text and extract tags in JSON as specified.\n\n${textForAnalysis}`

      const responseText = await generateChatCompletion(
        [
          { role: 'user', parts: [{ text: userPrompt }] }
        ],
        { model: 'gemini-2.0-flash', temperature: 0.1, responseFormat: 'json', systemInstruction }
      )

      const parsed = JSON.parse(responseText || '{}')
      aiTopics = parsed.topics || parsed.topic_tags || parsed.topics_list
      aiDiagnoses = parsed.diagnosis_keywords || parsed.diagnoses
      aiTreatments = parsed.treatment_keywords || parsed.treatments
    } catch (e) {
      // If Gemini fails or returns invalid JSON, we will fall back to heuristics below
    }

    const slugify = (s: string) =>
      s
        .toString()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '')
        .replace(/_+/g, '_')

    const unique = (arr: string[]) => Array.from(new Set(arr.filter(Boolean)))

    const topics = unique(
      (aiTopics && aiTopics.length > 0 ? aiTopics : heuristic.topics).map(slugify)
    ).slice(0, 8)

    const diagnosisKeywords = unique(
      (aiDiagnoses && aiDiagnoses.length > 0 ? aiDiagnoses : heuristic.diagnoses).map(slugify)
    ).slice(0, 8)

    const treatmentKeywords = unique(
      (aiTreatments && aiTreatments.length > 0 ? aiTreatments : heuristic.treatments).map(slugify)
    ).slice(0, 8)

    return {
      success: true,
      data: { topics, diagnosisKeywords, treatmentKeywords },
      extractedText: textForAnalysis,
      extractedPages: pdfContent.pages
    }
  } catch (error) {
    console.error('‚ùå [PDF KEYWORDS] Analysis error:', error)
    return { success: false, error: 'Failed to analyze keywords from PDF' }
  }
}

/**
 * Upload medical knowledge from PDF file
 * Extracts text and generates embeddings automatically
 */
export async function uploadMedicalKnowledgeFromPDFAction(pdfData: {
  pdfFile: File
  title?: string
  sourceType: 'textbook' | 'research_paper' | 'clinical_protocol' | 'case_study' | 'guideline'
  specialty: 'endodontics' | 'periodontics' | 'prosthodontics' | 'oral_surgery' | 'general_dentistry'
  authors?: string
  publicationYear?: number
  journal?: string
  doi?: string
  url?: string
  isbn?: string
  topics: string[]
  diagnosisKeywords: string[]
  treatmentKeywords: string[]
}) {
  try {
    // Get current user using proper auth pattern
    const user = await getCurrentUser()
    if (!user || user.role !== 'dentist' || user.status !== 'active') {
      console.error('‚ùå [PDF UPLOAD] Auth error: User not authorized')
      return { success: false, error: 'Only active dentists can upload medical knowledge' }
    }

    console.log('‚úÖ [PDF UPLOAD] User authenticated:', user.id, user.role)

    // Use service client for database operations
    const supabase = await createServiceClient()

    console.log('üìÑ [PDF UPLOAD] Starting PDF upload:', {
      fileName: pdfData.pdfFile.name,
      fileSize: pdfData.pdfFile.size,
      uploadedBy: user.id,
      userEmail: user.email
    })

    // Convert PDF to buffer
    const arrayBuffer = await pdfData.pdfFile.arrayBuffer()
    const buffer = Buffer.from(arrayBuffer)

    console.log('üìÑ [PDF UPLOAD] Extracting text from PDF...')

    // Extract text from PDF
    const { extractPDFContent } = await import('@/lib/utils/pdf-extractor')
    const pdfContent = await extractPDFContent(buffer)

    console.log(`‚úÖ [PDF UPLOAD] Extracted ${pdfContent.text.length} characters from ${pdfContent.pages} pages`)

    // Use provided title or extract from PDF
    const title = pdfData.title || pdfContent.title || pdfData.pdfFile.name.replace('.pdf', '')
    const authors = pdfData.authors || pdfContent.author || undefined

    // Generate embedding using Gemini
    const GEMINI_API_KEY = process.env.GEMINI_API_KEY
    if (!GEMINI_API_KEY) {
      return { success: false, error: 'GEMINI_API_KEY not configured. Please add it to .env.local' }
    }

    // Limit content for embedding (first 8000 chars)
    const embeddingText = `${title}\n\n${pdfContent.text.substring(0, 8000)}`

    console.log('üîÆ [PDF UPLOAD] Generating 768-dim embedding with Gemini...')

    const { generateEmbedding } = await import('@/lib/services/gemini-ai')

    let embedding: number[]
    try {
      embedding = await generateEmbedding(embeddingText, 'RETRIEVAL_DOCUMENT')
      console.log('‚úÖ [PDF UPLOAD] Gemini embedding generated, dimensions:', embedding.length)
    } catch (error) {
      console.error('‚ùå [PDF UPLOAD] Gemini embedding failed:', error)
      return { success: false, error: 'Failed to generate embeddings with Gemini API' }
    }

    // Insert into database with embedding
    const { data: knowledgeEntry, error: insertError } = await supabase
      .schema('api')
      .from('medical_knowledge')
      .insert({
        title,
        content: pdfContent.text, // Store full extracted text
        source_type: pdfData.sourceType,
        specialty: pdfData.specialty,
        authors: authors || null,
        publication_year: pdfData.publicationYear || null,
        journal: pdfData.journal || null,
        doi: pdfData.doi || null,
        url: pdfData.url || null,
        isbn: pdfData.isbn || null,
        embedding: embedding,
        topics: pdfData.topics,
        diagnosis_keywords: pdfData.diagnosisKeywords,
        treatment_keywords: pdfData.treatmentKeywords,
        uploaded_by: user.id,
        metadata: JSON.stringify({
          originalFileName: pdfData.pdfFile.name,
          pdfPages: pdfContent.pages,
          extractedAt: new Date().toISOString()
        })
      })
      .select()
      .single()

    if (insertError) {
      console.error('‚ùå [PDF UPLOAD] Database insert failed:', insertError)
      return { success: false, error: insertError.message }
    }

    console.log('‚úÖ [PDF UPLOAD] Successfully uploaded PDF:', knowledgeEntry.id)

    revalidatePath('/dentist')
    revalidatePath('/dentist/knowledge')

    return {
      success: true,
      data: knowledgeEntry,
      extractedText: pdfContent.text,
      extractedPages: pdfContent.pages
    }

  } catch (error) {
    console.error('‚ùå [PDF UPLOAD] Upload error:', error)
    return { success: false, error: `Failed to upload PDF: ${error instanceof Error ? error.message : 'Unknown error'}` }
  }
}
